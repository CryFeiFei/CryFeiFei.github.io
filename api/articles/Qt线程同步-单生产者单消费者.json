{"title":"Qt线程同步-单生产者单消费者","slug":"Qt线程同步-单生产者单消费者","date":"2020-07-01T12:42:54.000Z","updated":"2020-07-01T12:43:57.637Z","comments":true,"path":"api/articles/Qt线程同步-单生产者单消费者.json","excerpt":null,"covers":null,"content":"<h1 id=\"生产者消费者\"><a href=\"#生产者消费者\" class=\"headerlink\" title=\"生产者消费者\"></a>生产者消费者</h1><p>生产者消费者是个很经典的模型，我当时上学的时候，记得操作系统老师就讲过。</p>\n<p>现在我们用Qt的条件变量来实现。</p>\n<h1 id=\"QWaitCondition\"><a href=\"#QWaitCondition\" class=\"headerlink\" title=\"QWaitCondition\"></a>QWaitCondition</h1><p>Qt的环境变量为<code>QWaitCondition</code>，对应的CPP的类就是<code>std::condition_variable</code><br>用任意一个就可以。</p>\n<p>Qt是有官方的demo实现的。我觉得对于新手来讲不太好理解，而且并没有充分利用C++的RAII。这次我们自己来实现下<br>Qt的官方demo地址</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">Examples\\Qt<span class=\"token number\">-5.14</span><span class=\"token punctuation\">.</span><span class=\"token number\">2</span>\\corelib\\threads\\waitconditions</code></pre>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p>现在附上我的实现</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> DataSize <span class=\"token operator\">=</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span>\nQStringList listBuffer<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> bufferSize <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\nQWaitCondition bufferNotEmpty<span class=\"token punctuation\">;</span>\nQWaitCondition bufferNotFull<span class=\"token punctuation\">;</span>\nQMutex mutex<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Producer</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> QThread\n<span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">Producer</span><span class=\"token punctuation\">(</span>QObject <span class=\"token operator\">*</span>parent <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">QThread</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> override\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> DataSize<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            QMutexLocker <span class=\"token function\">locker</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>listBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> bufferSize<span class=\"token punctuation\">)</span>\n                bufferNotFull<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            QString strNumer <span class=\"token operator\">=</span> QString<span class=\"token operator\">::</span><span class=\"token function\">number</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">//假设生产者比较慢,一秒一个</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifdef</span> Q_OS_WIN</span>\n            <span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n            <span class=\"token function\">qDebug</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"producer----------\"</span><span class=\"token operator\">&lt;&lt;</span>strNumer<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n            listBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>strNumer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            bufferNotEmpty<span class=\"token punctuation\">.</span><span class=\"token function\">wakeAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Consumer</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> QThread\n<span class=\"token punctuation\">{</span>\n    Q_OBJECT\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">Consumer</span><span class=\"token punctuation\">(</span>QObject <span class=\"token operator\">*</span>parent <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">QThread</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> override\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            QMutexLocker <span class=\"token function\">locker</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>listBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                bufferNotEmpty<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            QString strText <span class=\"token operator\">=</span> listBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            listBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">pop_front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            bufferNotFull<span class=\"token punctuation\">.</span><span class=\"token function\">wakeAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">//在这里手动unlock.</span>\n            locker<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifdef</span> Q_OS_WIN</span>\n            <span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n            <span class=\"token comment\" spellcheck=\"true\">//最好在这里来消费，如果多个消费者，就不会卡主其它线程消费了。</span>\n            <span class=\"token function\">qDebug</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"consmer------\"</span><span class=\"token operator\">&lt;&lt;</span>strText<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<h1 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h1><p>看输出，一开始生产者是比消费者要快的,所以producer输出比较快</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">producer---------- <span class=\"token string\">\"0\"</span> \nproducer---------- <span class=\"token string\">\"1\"</span> \nconsmer------ <span class=\"token string\">\"0\"</span> \nproducer---------- <span class=\"token string\">\"2\"</span> \nproducer---------- <span class=\"token string\">\"3\"</span> \nproducer---------- <span class=\"token string\">\"4\"</span> \nconsmer------ <span class=\"token string\">\"1\"</span> \nproducer---------- <span class=\"token string\">\"5\"</span> </code></pre>\n<p>到后面，listBuffer塞满之后，慢慢的两个size的差距就是buffer的大小了。这当然是正常的。</p>\n<pre><code>producer---------- &quot;74&quot; \nconsmer------ &quot;64&quot; \nproducer---------- &quot;75&quot; \nconsmer------ &quot;65&quot; \nproducer---------- &quot;76&quot; \nconsmer------ &quot;66&quot; \nproducer---------- &quot;77&quot; </code></pre><h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>这是一个使用Qt的QMutex跟QWaitContidion来实现的一个经典的生产者消费者的模型。</p>\n<p>当然你可以<br>把我代码中的QWaitCondition替换成C++的std::condition_variable。<br>把QMutex替换成std::mutex。<br>把QMutexLocker 替换成 std::lock_gard或者 std::unique_lock。<br>这些都是可以的。</p>\n<p>个人觉得我的代码比Qt官方的代码好理解一些233333.</p>\n<p>附上工程代码<br><a href=\"https://github.com/CryFeiFei/Qt_Teach/tree/master/Qt_Teach/Thread_WaitCondition\" target=\"_blank\" rel=\"noopener\" title=\"https://github.com/CryFeiFei/Qt_Teach/tree/master/Qt_Teach/Thread_WaitCondition\">https://github.com/CryFeiFei/Qt_Teach/tree/master/Qt_Teach/Thread_WaitCondition</a></p>\n","more":"<h1 id=\"生产者消费者\"><a href=\"#生产者消费者\" class=\"headerlink\" title=\"生产者消费者\"></a>生产者消费者</h1><p>生产者消费者是个很经典的模型，我当时上学的时候，记得操作系统老师就讲过。</p>\n<p>现在我们用Qt的条件变量来实现。</p>\n<h1 id=\"QWaitCondition\"><a href=\"#QWaitCondition\" class=\"headerlink\" title=\"QWaitCondition\"></a>QWaitCondition</h1><p>Qt的环境变量为<code>QWaitCondition</code>，对应的CPP的类就是<code>std::condition_variable</code><br>用任意一个就可以。</p>\n<p>Qt是有官方的demo实现的。我觉得对于新手来讲不太好理解，而且并没有充分利用C++的RAII。这次我们自己来实现下<br>Qt的官方demo地址</p>\n<pre><code class=\"cpp\">Examples\\Qt-5.14.2\\corelib\\threads\\waitconditions</code></pre>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p>现在附上我的实现</p>\n<pre><code class=\"cpp\">\nconst int DataSize = 1000;\nQStringList listBuffer;\nconst int bufferSize = 10;\n\nQWaitCondition bufferNotEmpty;\nQWaitCondition bufferNotFull;\nQMutex mutex;\n\nclass Producer : public QThread\n{\npublic:\n    Producer(QObject *parent = NULL) : QThread(parent)\n    {\n    }\n    void run() override\n    {\n        for (int i = 0; i &lt; DataSize; ++i)\n        {\n            QMutexLocker locker(&amp;mutex);\n            if (listBuffer.size() == bufferSize)\n                bufferNotFull.wait(&amp;mutex);\n\n            QString strNumer = QString::number(i);\n\n            //假设生产者比较慢,一秒一个\n#ifdef Q_OS_WIN\n            Sleep(1000);\n#endif\n            qDebug()&lt;&lt;&quot;producer----------&quot;&lt;&lt;strNumer&lt;&lt;endl;\n            listBuffer.push_back(strNumer);\n            bufferNotEmpty.wakeAll();\n        }\n    }\n};\n\nclass Consumer : public QThread\n{\n    Q_OBJECT\npublic:\n    Consumer(QObject *parent = NULL) : QThread(parent)\n    {\n    }\n\n    void run() override\n    {\n        while(true)\n        {\n            QMutexLocker locker(&amp;mutex);\n            if (listBuffer.isEmpty())\n                bufferNotEmpty.wait(&amp;mutex);\n\n            QString strText = listBuffer.front();\n            listBuffer.pop_front();\n            bufferNotFull.wakeAll();\n\n            //在这里手动unlock.\n            locker.unlock();\n#ifdef Q_OS_WIN\n            Sleep(2000);\n#endif\n            //最好在这里来消费，如果多个消费者，就不会卡主其它线程消费了。\n            qDebug()&lt;&lt;&quot;consmer------&quot;&lt;&lt;strText&lt;&lt;endl;\n\n        }\n    }\n};</code></pre>\n<h1 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h1><p>看输出，一开始生产者是比消费者要快的,所以producer输出比较快</p>\n<pre><code class=\"bash\">producer---------- &quot;0&quot; \nproducer---------- &quot;1&quot; \nconsmer------ &quot;0&quot; \nproducer---------- &quot;2&quot; \nproducer---------- &quot;3&quot; \nproducer---------- &quot;4&quot; \nconsmer------ &quot;1&quot; \nproducer---------- &quot;5&quot; </code></pre>\n<p>到后面，listBuffer塞满之后，慢慢的两个size的差距就是buffer的大小了。这当然是正常的。</p>\n<pre><code>producer---------- &quot;74&quot; \nconsmer------ &quot;64&quot; \nproducer---------- &quot;75&quot; \nconsmer------ &quot;65&quot; \nproducer---------- &quot;76&quot; \nconsmer------ &quot;66&quot; \nproducer---------- &quot;77&quot; </code></pre><h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>这是一个使用Qt的QMutex跟QWaitContidion来实现的一个经典的生产者消费者的模型。</p>\n<p>当然你可以<br>把我代码中的QWaitCondition替换成C++的std::condition_variable。<br>把QMutex替换成std::mutex。<br>把QMutexLocker 替换成 std::lock_gard或者 std::unique_lock。<br>这些都是可以的。</p>\n<p>个人觉得我的代码比Qt官方的代码好理解一些233333.</p>\n<p>附上工程代码<br><a href=\"https://github.com/CryFeiFei/Qt_Teach/tree/master/Qt_Teach/Thread_WaitCondition\" target=\"_blank\" rel=\"noopener\" title=\"https://github.com/CryFeiFei/Qt_Teach/tree/master/Qt_Teach/Thread_WaitCondition\">https://github.com/CryFeiFei/Qt_Teach/tree/master/Qt_Teach/Thread_WaitCondition</a></p>\n","categories":[{"name":"Qt","path":"api/categories/Qt.json"},{"name":"Qt基础教程","path":"api/categories/Qt基础教程.json"}],"tags":[{"name":"Qt","path":"api/tags/Qt.json"},{"name":"生产者","path":"api/tags/生产者.json"},{"name":"消费者","path":"api/tags/消费者.json"}]}