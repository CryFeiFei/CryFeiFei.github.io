{"title":"Qt释放线程资源的一些工程上的方法","slug":"Qt释放线程资源的一些工程上的方法","date":"2020-07-01T12:45:56.000Z","updated":"2020-07-01T12:47:32.609Z","comments":true,"path":"api/articles/Qt释放线程资源的一些工程上的方法.json","excerpt":null,"covers":null,"content":"<h1 id=\"Qt官方文档的方法\"><a href=\"#Qt官方文档的方法\" class=\"headerlink\" title=\"Qt官方文档的方法\"></a>Qt官方文档的方法</h1><blockquote>\n<p>QThread创建在栈上，然后QObject需要配合QThread释放资源<br>直接上代码。结束的时候线程quit and wait</p>\n</blockquote>\n<p>直接上代码</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Controller</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> QObject\n<span class=\"token punctuation\">{</span>\n    Q_OBJECT\n    QThread workerThread<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">Controller</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Worker <span class=\"token operator\">*</span>worker <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Worker<span class=\"token punctuation\">;</span>\n        worker<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">moveToThread</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>workerThread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>workerThread<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>QThread<span class=\"token operator\">::</span>finished<span class=\"token punctuation\">,</span> worker<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>QObject<span class=\"token operator\">::</span>deleteLater<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token operator\">~</span><span class=\"token function\">Controller</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        workerThread<span class=\"token punctuation\">.</span><span class=\"token function\">quit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        workerThread<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<p>上了关键核心代码。<br>直接按照顺序来说。</p>\n<h2 id=\"1-观察析构函数\"><a href=\"#1-观察析构函数\" class=\"headerlink\" title=\"1.观察析构函数\"></a>1.观察析构函数</h2><pre class=\" language-cpp\"><code class=\"language-cpp\">    <span class=\"token operator\">~</span><span class=\"token function\">Controller</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        workerThread<span class=\"token punctuation\">.</span><span class=\"token function\">quit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        workerThread<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<p>一步步来</p>\n<ul>\n<li>工作线程quit跟wait退出结束，发出finished信号。</li>\n</ul>\n<h2 id=\"2-线程退出\"><a href=\"#2-线程退出\" class=\"headerlink\" title=\"2. 线程退出\"></a>2. 线程退出</h2><pre class=\" language-cpp\"><code class=\"language-cpp\">        <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>workerThread<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>QThread<span class=\"token operator\">::</span>finished<span class=\"token punctuation\">,</span> worker<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>QObject<span class=\"token operator\">::</span>deleteLater<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>线程退出通知QObject对象删除</p>\n<h2 id=\"3-QThread释放\"><a href=\"#3-QThread释放\" class=\"headerlink\" title=\"3. QThread释放\"></a>3. QThread释放</h2><p>由于QThread在栈上，所以会自己销毁。</p>\n<p>这三部完美的释放了线程资源。</p>\n<h1 id=\"我的做法\"><a href=\"#我的做法\" class=\"headerlink\" title=\"我的做法\"></a>我的做法</h1><p>我上面讲的第二种方法实际上一开始写的并不好，虽说你把我的代码QObject跟QThraed加上析构函数输出发现也会释放，但是还是会有一些小问题。感谢知乎大佬指出来了。我直接上正确的结论。</p>\n<p>工程代码在这里<br><a href=\"https://github.com/CryFeiFei/Qt_Teach/tree/master/Qt_Teach/Thread2\" target=\"_blank\" rel=\"noopener\">https://github.com/CryFeiFei/Qt_Teach/tree/master/Qt_Teach/Thread2</a></p>\n<p>我的QThread是放到堆上的。即下面的KThread</p>\n<p>直接上我的代码。</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">    m_workerThread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">KThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    WorkThread<span class=\"token operator\">*</span> worker <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">WorkThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    worker<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">moveToThread</span><span class=\"token punctuation\">(</span>m_workerThread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//等工作的QObject结束，让线程停止结束</span>\n    <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>WorkThread<span class=\"token operator\">::</span>workFinished<span class=\"token punctuation\">,</span> m_workerThread<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        m_workerThread<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">quit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        m_workerThread<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//线程停止发给QObject让他自己销毁。</span>\n    <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>m_workerThread<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>QThread<span class=\"token operator\">::</span>finished<span class=\"token punctuation\">,</span> worker<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>WorkThread<span class=\"token operator\">::</span>deleteLater<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// QObject销毁之后，让线程自己销毁。</span>\n    <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>WorkThread<span class=\"token operator\">::</span>destroyed<span class=\"token punctuation\">,</span> m_workerThread<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>QThread<span class=\"token operator\">::</span>deleteLater<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>解释都在备注上。</p>\n<p>对比Qt官方的文档，也就是把QThread申请放到了堆上，然后多了一步释放QThread的操作。<br>即</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">    <span class=\"token comment\" spellcheck=\"true\">// QObject销毁之后，让线程自己销毁。</span>\n    <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>WorkThread<span class=\"token operator\">::</span>destroyed<span class=\"token punctuation\">,</span> m_workerThread<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>QThread<span class=\"token operator\">::</span>deleteLater<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>有兴趣可以自己下载代码调试下，会发现KThread跟worker的析构函数都完美释放了。</p>\n<h1 id=\"释放线程资源必须要做的（避免死锁\"><a href=\"#释放线程资源必须要做的（避免死锁\" class=\"headerlink\" title=\"释放线程资源必须要做的（避免死锁\"></a>释放线程资源必须要做的（避免死锁</h1><p><em>一定要等线程停止之后，再销毁线程</em></p>\n<h3 id=\"QWaitCondition\"><a href=\"#QWaitCondition\" class=\"headerlink\" title=\"QWaitCondition\"></a>QWaitCondition</h3><blockquote>\n<p>一定要等线程停止之后，再销毁线程</p>\n</blockquote>\n<p>生产者消费者是用QWaitCondition来进行同步的。</p>\n<p>现在我想手动把这个流程停掉</p>\n<p>大概有这么几种情况。</p>\n<p>比如生产者生产过快，还在wait，这时候我们的线程需要马上停止。</p>\n<p>生产者线程在这里wait</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>listBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> bufferSize<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    bufferNotFull<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这时候是没有办法把生产者停掉的，如果强行delete，那就未知了，运气好，不崩溃，运气差，就crash了。</p>\n<p>再看看我们的控制代码是在上面这段代码之前的。</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//xxxxxxx</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>m_bPause<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        emit <span class=\"token function\">workPause</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//..................</span>\n    <span class=\"token comment\" spellcheck=\"true\">//xxxxx</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>listBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> bufferSize<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        bufferNotFull<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//xxxxxxx</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>也就是这里死锁之后，我们的生产者是永远停不了的。</p>\n<p>同理，消费者过快也会出现这个问题。</p>\n<p>所以需要我们在释放这种资源的时候要手动调用下两个条件变量的</p>\n<pre class=\" language-cpp\"><code class=\"language-cpp\">xxxx<span class=\"token punctuation\">.</span><span class=\"token function\">wakeAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nxxxx<span class=\"token punctuation\">.</span><span class=\"token function\">wakeAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>这样能够避免线程释放资源发生死锁。导致crash。</p>\n<h3 id=\"还有一个方法。\"><a href=\"#还有一个方法。\" class=\"headerlink\" title=\"还有一个方法。\"></a>还有一个方法。</h3><p>QWaitCondition 的wait是有一个超时时间的，你可以设定一个超时时间，这样就会进入下一次循环，也会避免死锁了。逃）</p>\n<p>PS。所有的代码都更新已经放到了github上。公众号的文章发了不能改，以我的代码为准吧。</p>\n","more":"<h1 id=\"Qt官方文档的方法\"><a href=\"#Qt官方文档的方法\" class=\"headerlink\" title=\"Qt官方文档的方法\"></a>Qt官方文档的方法</h1><blockquote>\n<p>QThread创建在栈上，然后QObject需要配合QThread释放资源<br>直接上代码。结束的时候线程quit and wait</p>\n</blockquote>\n<p>直接上代码</p>\n<pre><code class=\"cpp\">class Controller : public QObject\n{\n    Q_OBJECT\n    QThread workerThread;\npublic:\n    Controller() {\n        Worker *worker = new Worker;\n        worker-&gt;moveToThread(&amp;workerThread);\n        connect(&amp;workerThread, &amp;QThread::finished, worker, &amp;QObject::deleteLater);\n\n    ~Controller() {\n        workerThread.quit();\n        workerThread.wait();\n    }</code></pre>\n<p>上了关键核心代码。<br>直接按照顺序来说。</p>\n<h2 id=\"1-观察析构函数\"><a href=\"#1-观察析构函数\" class=\"headerlink\" title=\"1.观察析构函数\"></a>1.观察析构函数</h2><pre><code class=\"cpp\">    ~Controller() {\n        workerThread.quit();\n        workerThread.wait();\n    }</code></pre>\n<p>一步步来</p>\n<ul>\n<li>工作线程quit跟wait退出结束，发出finished信号。</li>\n</ul>\n<h2 id=\"2-线程退出\"><a href=\"#2-线程退出\" class=\"headerlink\" title=\"2. 线程退出\"></a>2. 线程退出</h2><pre><code class=\"cpp\">        connect(&amp;workerThread, &amp;QThread::finished, worker, &amp;QObject::deleteLater);</code></pre>\n<p>线程退出通知QObject对象删除</p>\n<h2 id=\"3-QThread释放\"><a href=\"#3-QThread释放\" class=\"headerlink\" title=\"3. QThread释放\"></a>3. QThread释放</h2><p>由于QThread在栈上，所以会自己销毁。</p>\n<p>这三部完美的释放了线程资源。</p>\n<h1 id=\"我的做法\"><a href=\"#我的做法\" class=\"headerlink\" title=\"我的做法\"></a>我的做法</h1><p>我上面讲的第二种方法实际上一开始写的并不好，虽说你把我的代码QObject跟QThraed加上析构函数输出发现也会释放，但是还是会有一些小问题。感谢知乎大佬指出来了。我直接上正确的结论。</p>\n<p>工程代码在这里<br><a href=\"https://github.com/CryFeiFei/Qt_Teach/tree/master/Qt_Teach/Thread2\" target=\"_blank\" rel=\"noopener\">https://github.com/CryFeiFei/Qt_Teach/tree/master/Qt_Teach/Thread2</a></p>\n<p>我的QThread是放到堆上的。即下面的KThread</p>\n<p>直接上我的代码。</p>\n<pre><code class=\"cpp\">    m_workerThread = new KThread();\n    WorkThread* worker = new WorkThread();\n    worker-&gt;moveToThread(m_workerThread);\n\n    //等工作的QObject结束，让线程停止结束\n    connect(worker, &amp;WorkThread::workFinished, m_workerThread, [this]()\n    {\n        m_workerThread-&gt;quit();\n        m_workerThread-&gt;wait();\n    });\n\n    //线程停止发给QObject让他自己销毁。\n    connect(m_workerThread, &amp;QThread::finished, worker, &amp;WorkThread::deleteLater);\n\n    // QObject销毁之后，让线程自己销毁。\n    connect(worker, &amp;WorkThread::destroyed, m_workerThread, &amp;QThread::deleteLater);</code></pre>\n<p>解释都在备注上。</p>\n<p>对比Qt官方的文档，也就是把QThread申请放到了堆上，然后多了一步释放QThread的操作。<br>即</p>\n<pre><code class=\"cpp\">    // QObject销毁之后，让线程自己销毁。\n    connect(worker, &amp;WorkThread::destroyed, m_workerThread, &amp;QThread::deleteLater);</code></pre>\n<p>有兴趣可以自己下载代码调试下，会发现KThread跟worker的析构函数都完美释放了。</p>\n<h1 id=\"释放线程资源必须要做的（避免死锁\"><a href=\"#释放线程资源必须要做的（避免死锁\" class=\"headerlink\" title=\"释放线程资源必须要做的（避免死锁\"></a>释放线程资源必须要做的（避免死锁</h1><p><em>一定要等线程停止之后，再销毁线程</em></p>\n<h3 id=\"QWaitCondition\"><a href=\"#QWaitCondition\" class=\"headerlink\" title=\"QWaitCondition\"></a>QWaitCondition</h3><blockquote>\n<p>一定要等线程停止之后，再销毁线程</p>\n</blockquote>\n<p>生产者消费者是用QWaitCondition来进行同步的。</p>\n<p>现在我想手动把这个流程停掉</p>\n<p>大概有这么几种情况。</p>\n<p>比如生产者生产过快，还在wait，这时候我们的线程需要马上停止。</p>\n<p>生产者线程在这里wait</p>\n<pre><code class=\"cpp\">if (listBuffer.size() == bufferSize)\n{\n    bufferNotFull.wait(&amp;mutex);\n}</code></pre>\n<p>这时候是没有办法把生产者停掉的，如果强行delete，那就未知了，运气好，不崩溃，运气差，就crash了。</p>\n<p>再看看我们的控制代码是在上面这段代码之前的。</p>\n<pre><code class=\"cpp\">while(1)\n{\n    //xxxxxxx\n    if (m_bPause)\n    {\n        emit workPause();\n        continue;\n    }\n    //..................\n    //xxxxx\n    if (listBuffer.size() == bufferSize)\n    {\n        bufferNotFull.wait(&amp;mutex);\n    }\n\n    //xxxxxxx\n}\n</code></pre>\n<p>也就是这里死锁之后，我们的生产者是永远停不了的。</p>\n<p>同理，消费者过快也会出现这个问题。</p>\n<p>所以需要我们在释放这种资源的时候要手动调用下两个条件变量的</p>\n<pre><code class=\"cpp\">xxxx.wakeAll();\nxxxx.wakeAll();</code></pre>\n<p>这样能够避免线程释放资源发生死锁。导致crash。</p>\n<h3 id=\"还有一个方法。\"><a href=\"#还有一个方法。\" class=\"headerlink\" title=\"还有一个方法。\"></a>还有一个方法。</h3><p>QWaitCondition 的wait是有一个超时时间的，你可以设定一个超时时间，这样就会进入下一次循环，也会避免死锁了。逃）</p>\n<p>PS。所有的代码都更新已经放到了github上。公众号的文章发了不能改，以我的代码为准吧。</p>\n","categories":[{"name":"Qt","path":"api/categories/Qt.json"},{"name":"Qt基础教程","path":"api/categories/Qt基础教程.json"}],"tags":[{"name":"Qt","path":"api/tags/Qt.json"},{"name":"死锁","path":"api/tags/死锁.json"},{"name":"线程","path":"api/tags/线程.json"}]}