{"title":"Qt打印机原理源码剖析_Linux","slug":"Qt打印机原理源码剖析-Linux","date":"2020-06-27T05:51:55.000Z","updated":"2020-06-27T06:26:06.010Z","comments":true,"path":"api/articles/Qt打印机原理源码剖析-Linux.json","excerpt":null,"covers":null,"content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Qt在Linux下打印机的原理以及源码相关知识。<br>下边我就详细的讲一下Linux下的打印机原理。</p>\n<h1 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h1><p>Linux下简单的流程就是这样</p>\n<div id=\"flowchart-0\" class=\"flow-chart\"></div>\n\n\n<h1 id=\"CUPS\"><a href=\"#CUPS\" class=\"headerlink\" title=\"CUPS\"></a>CUPS</h1><p>目前Linux上打印的通用协议是CUPS协议。目前由苹果公司来维护。算了我还是粘一下wiki的词条吧。</p>\n<p>wiki词条</p>\n<blockquote>\n<p>CUPS (formerly an acronym for Common UNIX Printing System) is a modular printing system for Unix-like computer operating systems which allows a computer to act as a print server. A computer running CUPS is a host that can accept print jobs from client computers, process them, and send them to the appropriate printer.<br>CUPS consists of a print spooler and scheduler, a filter system that converts the print data to a format that the printer will understand, and a backend system that sends this data to the print device. CUPS uses the Internet Printing Protocol (IPP) as the basis for managing print jobs and queues. It also provides the traditional command line interfaces for the System V and Berkeley print systems, and provides support for the Berkeley print system’s Line Printer Daemon protocol and limited support for the server message block (SMB) protocol. System administrators can configure the device drivers which CUPS supplies by editing text files in Adobe’s PostScript Printer Description (PPD) format. There are a number of user interfaces for different pl#atforms that can configure CUPS, and it has a built-in web-based interface. CUPS is free software, provided under the Apache License. </p>\n</blockquote>\n<blockquote>\n<p>CUPS（前为Common Unix Printing System，即UNIX通用打印系统的缩写，但现无官方全名[来源请求]）是一个类Unix操作系统的组合式印刷系统，允许一台计算机作为打印服务器。CUPS接受一个客户端的计算机进程，并送到相应的打印机。<br>CUPS是自由软件，使用GNU通用公共许可证和GNU宽通用公共许可证的第2版。<br>迈克尔·斯维特，Easy Software Products的拥有者，于1997年开始开发CUPS。首次公开测试版于1999年发布。[2]原本设计的CUPS使用行式打印机后台程序协议，但由于LPD的限制和供应商不兼容，所以由互联网打印协议(IPP)代替。CUPS被迅速默认为一些Linux发行版的打印系统，如Red Hat Linux。2002年3月，苹果公司在Mac OS X v10.2中采用了CUPS。[3]2007年2月，苹果公司聘请了迈克尔·斯维特并购买了CUPS的源代码。[4]</p>\n</blockquote>\n<p>再次说一遍 <em>目前Unix系列的打印原理都是走的该协议。</em></p>\n<h2 id=\"CUPS是开源的\"><a href=\"#CUPS是开源的\" class=\"headerlink\" title=\"CUPS是开源的\"></a>CUPS是开源的</h2><ul>\n<li>官网 <a href=\"https://www.cups.org/\" target=\"_blank\" rel=\"noopener\">https://www.cups.org/</a> </li>\n<li>源码 <a href=\"https://github.com/apple/cups\" target=\"_blank\" rel=\"noopener\">https://github.com/apple/cups</a></li>\n</ul>\n<p>我读过这里的源码，为了验证下边有个纠结的问题。全是c写的，也不难。</p>\n<h2 id=\"Linux下的驱动\"><a href=\"#Linux下的驱动\" class=\"headerlink\" title=\"Linux下的驱动\"></a>Linux下的驱动</h2><p>秉承着Linux下的原则，一切皆文件，实际上Linux下的打印机驱动也是文件，在目录/etc/cups/ppd文件夹下。可以随意装个虚拟驱动来看下</p>\n<p>简单的给大家看几行ppd文件，这是我本地下的驱动文件</p>\n<pre><code>*PPD-Adobe: &quot;4.3&quot;\n*%%%% PPD file for Generic Text-Only Printer with CUPS.\n*%%%% Created by the CUPS PPD Compiler CUPS v2.2.7.\n*% (c) 2014 OpenPrinting\n*FormatVersion: &quot;4.3&quot;\n*FileVersion: &quot;1.0&quot;\n*LanguageVersion: English\n*LanguageEncoding: ISOLatin1\n*PCFileName: &quot;textonly.ppd&quot;\n*Product: &quot;(Generic Text-Only Printer)&quot;\n*Manufacturer: &quot;Generic&quot;\n*ModelName: &quot;Generic Text-Only Printer&quot;\n*ShortNickName: &quot;Generic Text-Only Printer&quot;\n*NickName: &quot;Generic Text-Only Printer&quot;\n*PSVersion: &quot;(3010.000) 0&quot;\n*LanguageLevel: &quot;3&quot;\n*ColorDevice: False\n*DefaultColorSpace: Gray\n*FileSystem: False\n*Throughput: &quot;1&quot;\n*LandscapeOrientation: Plus90\n*TTRasterizer: Type42\n*% Driver-defined attributes...\n*cupsFilter2: &quot;text/plain text/plain 0 texttotext&quot;\n*RequiresPageRegion All: True\n*1284DeviceID: &quot;MFG:Generic;MDL:Text-Only Printer;DES:Generic Text-Only Printer;CLS:PRINTER;CMD:TXT;DRV:Dtextonly,R1,M0;&quot;\n*cupsVersion: 2.2\n*cupsModelNumber: 0\n*cupsManualCopies: True\n*cupsFilter: &quot;text/plain 0 texttotext&quot;\n*cupsLanguages: &quot;en&quot;</code></pre><p>里边主要是一些字符串信息。你可以简单的理解，cups就是来解析ppd文件中的字符串信息的。</p>\n<h2 id=\"Qt对CUPS的支持。\"><a href=\"#Qt对CUPS的支持。\" class=\"headerlink\" title=\"Qt对CUPS的支持。\"></a>Qt对CUPS的支持。</h2><p>实际上Qt对CUPS的支持是相当好的，源码级别的话都不到千行，将cups提供的信息封装了一层Qt的API来给大家使用。实际上QPrinter也是调用的Qt封装的QCUPSSupport。注意一下QPrinter在Linux下的初始化是非常慢的。不要频繁调用。</p>\n<p>上源码QCUPSSupport</p>\n<pre><code>//Qt4.8.7/qt-everywhere-opensource-src-4.8.7/src/gui/painting/ 源码在这里\n/****************************************************************************\n**\n** Copyright (C) 2015 The Qt Company Ltd.\n** Contact: http://www.qt.io/licensing/\n**\n** This file is part of the QtGui module of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:LGPL$\n** Commercial License Usage\n** Licensees holding valid commercial Qt licenses may use this file in\n** accordance with the commercial license agreement provided with the\n** Software or, alternatively, in accordance with the terms contained in\n** a written agreement between you and The Qt Company. For licensing terms\n** and conditions see http://www.qt.io/terms-conditions. For further\n** information use the contact form at http://www.qt.io/contact-us.\n**\n** GNU Lesser General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU Lesser\n** General Public License version 2.1 or version 3 as published by the Free\n** Software Foundation and appearing in the file LICENSE.LGPLv21 and\n** LICENSE.LGPLv3 included in the packaging of this file. Please review the\n** following information to ensure the GNU Lesser General Public License\n** requirements will be met: https://www.gnu.org/licenses/lgpl.html and\n** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.\n**\n** As a special exception, The Qt Company gives you certain additional\n** rights. These rights are described in The Qt Company LGPL Exception\n** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.\n**\n** GNU General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU\n** General Public License version 3.0 as published by the Free Software\n** Foundation and appearing in the file LICENSE.GPL included in the\n** packaging of this file. Please review the following information to\n** ensure the GNU General Public License version 3.0 requirements will be\n** met: http://www.gnu.org/copyleft/gpl.html.\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n#ifndef QCUPS_P_H\n#define QCUPS_P_H\n//\n// W A R N I N G\n// -------------\n//\n// This file is not part of the Qt API. It exists purely as an\n// implementation detail. This header file may change from version to\n// version without notice, or even be removed.\n//\n// We mean it.\n//\n#include &quot;QtCore/qstring.h&quot;\n#include &quot;QtCore/qstringlist.h&quot;\n#include &quot;QtGui/qprinter.h&quot;\n#ifndef QT_NO_CUPS\n#include &lt;QtCore/qlibrary.h&gt;\n#include &lt;cups/cups.h&gt;\n#include &lt;cups/ppd.h&gt;\nQT_BEGIN_NAMESPACE\nQ_DECLARE_TYPEINFO(cups_option_t, Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE);\nclass QCUPSSupport\n{\npublic:\n    QCUPSSupport();\n    ~QCUPSSupport();\n    static bool isAvailable();\n    static int cupsVersion() { return isAvailable() ? CUPS_VERSION_MAJOR*10000+CUPS_VERSION_MINOR*100+CUPS_VERSION_PATCH : 0; }\n    int availablePrintersCount() const;\n    const cups_dest_t* availablePrinters() const;\n    int currentPrinterIndex() const;\n    const ppd_file_t* setCurrentPrinter(int index);\n    const ppd_file_t* currentPPD() const;\n    const ppd_option_t* ppdOption(const char *key) const;\n    const cups_option_t* printerOption(const QString &amp;key) const;\n    const ppd_option_t* pageSizes() const;\n    int markOption(const char* name, const char* value);\n    void saveOptions(QList&lt;const ppd_option_t*&gt; options, QList&lt;const char*&gt; markedOptions);\n    QRect paperRect(const char *choice) const;\n    QRect pageRect(const char *choice) const;\n    QStringList options() const;\n    static bool printerHasPPD(const char *printerName);\n    QString unicodeString(const char *s);\n    QPair&lt;int, QString&gt; tempFd();\n    int printFile(const char * printerName, const char * filename, const char * title,\n                  int num_options, cups_option_t * options);\nprivate:\n    void collectMarkedOptions(QStringList&amp; list, const ppd_group_t* group = 0) const;\n    void collectMarkedOptionsHelper(QStringList&amp; list, const ppd_group_t* group) const;\n    int prnCount;\n    cups_dest_t *printers;\n    const ppd_option_t* page_sizes;\n    int currPrinterIndex;\n    ppd_file_t *currPPD;\n#ifndef QT_NO_TEXTCODEC\n    QTextCodec *codec;\n#endif\n};\nQT_END_NAMESPACE\n#endif // QT_NO_CUPS\n#endif</code></pre><p>cpp</p>\n<pre><code>//Qt4.8.7/qt-everywhere-opensource-src-4.8.7/src/gui/painting/qcups.cpp\n\n/****************************************************************************\n**\n** Copyright (C) 2015 The Qt Company Ltd.\n** Contact: http://www.qt.io/licensing/\n**\n** This file is part of the QtGui module of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:LGPL$\n** Commercial License Usage\n** Licensees holding valid commercial Qt licenses may use this file in\n** accordance with the commercial license agreement provided with the\n** Software or, alternatively, in accordance with the terms contained in\n** a written agreement between you and The Qt Company. For licensing terms\n** and conditions see http://www.qt.io/terms-conditions. For further\n** information use the contact form at http://www.qt.io/contact-us.\n**\n** GNU Lesser General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU Lesser\n** General Public License version 2.1 or version 3 as published by the Free\n** Software Foundation and appearing in the file LICENSE.LGPLv21 and\n** LICENSE.LGPLv3 included in the packaging of this file. Please review the\n** following information to ensure the GNU Lesser General Public License\n** requirements will be met: https://www.gnu.org/licenses/lgpl.html and\n** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.\n**\n** As a special exception, The Qt Company gives you certain additional\n** rights. These rights are described in The Qt Company LGPL Exception\n** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.\n**\n** GNU General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU\n** General Public License version 3.0 as published by the Free Software\n** Foundation and appearing in the file LICENSE.GPL included in the\n** packaging of this file. Please review the following information to\n** ensure the GNU General Public License version 3.0 requirements will be\n** met: http://www.gnu.org/copyleft/gpl.html.\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n#include &lt;qdebug.h&gt;\n#include &quot;qcups_p.h&quot;\n#ifndef QT_NO_CUPS\n#ifndef QT_LINUXBASE // LSB merges everything into cups.h\n# include &lt;cups/language.h&gt;\n#endif\n#include &lt;qtextcodec.h&gt;\nQT_BEGIN_NAMESPACE\ntypedef int (*CupsGetDests)(cups_dest_t **dests);\ntypedef void (*CupsFreeDests)(int num_dests, cups_dest_t *dests);\ntypedef const char* (*CupsGetPPD)(const char *printer);\ntypedef int (*CupsMarkOptions)(ppd_file_t *ppd, int num_options, cups_option_t *options);\ntypedef ppd_file_t* (*PPDOpenFile)(const char *filename);\ntypedef void (*PPDMarkDefaults)(ppd_file_t *ppd);\ntypedef int (*PPDMarkOption)(ppd_file_t *ppd, const char *keyword, const char *option);\ntypedef void (*PPDClose)(ppd_file_t *ppd);\ntypedef int (*PPDMarkOption)(ppd_file_t *ppd, const char *keyword, const char *option);\ntypedef void (*CupsFreeOptions)(int num_options, cups_option_t *options);\ntypedef void (*CupsSetDests)(int num_dests, cups_dest_t *dests);\ntypedef cups_lang_t* (*CupsLangGet)(const char *language);\ntypedef const char* (*CupsLangEncoding)(cups_lang_t *language);\ntypedef int (*CupsAddOption)(const char *name, const char *value, int num_options, cups_option_t **options);\ntypedef int (*CupsTempFd)(char *name, int len);\ntypedef int (*CupsPrintFile)(const char * name, const char * filename, const char * title, int num_options, cups_option_t * options);\nstatic bool cupsLoaded = false;\nstatic int qt_cups_num_printers = 0;\nstatic CupsGetDests _cupsGetDests = 0;\nstatic CupsFreeDests _cupsFreeDests = 0;\nstatic CupsGetPPD _cupsGetPPD = 0;\nstatic PPDOpenFile _ppdOpenFile = 0;\nstatic PPDMarkDefaults _ppdMarkDefaults = 0;\nstatic PPDClose _ppdClose = 0;\nstatic CupsMarkOptions _cupsMarkOptions = 0;\nstatic PPDMarkOption _ppdMarkOption = 0;\nstatic CupsFreeOptions _cupsFreeOptions = 0;\nstatic CupsSetDests _cupsSetDests = 0;\nstatic CupsLangGet _cupsLangGet = 0;\nstatic CupsLangEncoding _cupsLangEncoding = 0;\nstatic CupsAddOption _cupsAddOption = 0;\nstatic CupsTempFd _cupsTempFd = 0;\nstatic CupsPrintFile _cupsPrintFile = 0;\nstatic void resolveCups()\n{\n    QLibrary cupsLib(QLatin1String(&quot;cups&quot;), 2);\n    if(cupsLib.load()) {\n        _cupsGetDests = (CupsGetDests) cupsLib.resolve(&quot;cupsGetDests&quot;);\n        _cupsFreeDests = (CupsFreeDests) cupsLib.resolve(&quot;cupsFreeDests&quot;);\n        _cupsGetPPD = (CupsGetPPD) cupsLib.resolve(&quot;cupsGetPPD&quot;);\n        _cupsLangGet = (CupsLangGet) cupsLib.resolve(&quot;cupsLangGet&quot;);\n        _cupsLangEncoding = (CupsLangEncoding) cupsLib.resolve(&quot;cupsLangEncoding&quot;);\n        _ppdOpenFile = (PPDOpenFile) cupsLib.resolve(&quot;ppdOpenFile&quot;);\n        _ppdMarkDefaults = (PPDMarkDefaults) cupsLib.resolve(&quot;ppdMarkDefaults&quot;);\n        _ppdClose = (PPDClose) cupsLib.resolve(&quot;ppdClose&quot;);\n        _cupsMarkOptions = (CupsMarkOptions) cupsLib.resolve(&quot;cupsMarkOptions&quot;);\n        _ppdMarkOption = (PPDMarkOption) cupsLib.resolve(&quot;ppdMarkOption&quot;);\n        _cupsFreeOptions = (CupsFreeOptions) cupsLib.resolve(&quot;cupsFreeOptions&quot;);\n        _cupsSetDests = (CupsSetDests) cupsLib.resolve(&quot;cupsSetDests&quot;);\n        _cupsAddOption = (CupsAddOption) cupsLib.resolve(&quot;cupsAddOption&quot;);\n        _cupsTempFd = (CupsTempFd) cupsLib.resolve(&quot;cupsTempFd&quot;);\n        _cupsPrintFile = (CupsPrintFile) cupsLib.resolve(&quot;cupsPrintFile&quot;);\n        if (_cupsGetDests &amp;&amp; _cupsFreeDests) {\n            cups_dest_t *printers;\n            int num_printers = _cupsGetDests(&amp;printers);\n            if (num_printers)\n                _cupsFreeDests(num_printers, printers);\n            qt_cups_num_printers = num_printers;\n        }\n    }\n    cupsLoaded = true;\n}\n// ================ CUPS Support class ========================\nQCUPSSupport::QCUPSSupport()\n    :\n    prnCount(0),\n    printers(0),\n    page_sizes(0),\n    currPrinterIndex(0),\n    currPPD(0)\n{\n    if (!cupsLoaded)\n        resolveCups();\n    // getting all available printers\n    if (!isAvailable())\n        return;\n    // Update the available printer count\n    qt_cups_num_printers = prnCount = _cupsGetDests(&amp;printers);\n    for (int i = 0; i &lt; prnCount; ++i) {\n        if (printers[i].is_default) {\n            currPrinterIndex = i;\n            setCurrentPrinter(i);\n            break;\n        }\n    }\n#ifndef QT_NO_TEXTCODEC\n    cups_lang_t *cupsLang = _cupsLangGet(0);\n    codec = QTextCodec::codecForName(_cupsLangEncoding(cupsLang));\n    if (!codec)\n        codec = QTextCodec::codecForLocale();\n#endif\n}\nQCUPSSupport::~QCUPSSupport()\n{\n     if (currPPD)\n        _ppdClose(currPPD);\n     if (prnCount)\n         _cupsFreeDests(prnCount, printers);\n}\nint QCUPSSupport::availablePrintersCount() const\n{\n    return prnCount;\n}\nconst cups_dest_t* QCUPSSupport::availablePrinters() const\n{\n    return printers;\n}\nconst ppd_file_t* QCUPSSupport::currentPPD() const\n{\n    return currPPD;\n}\nconst ppd_file_t* QCUPSSupport::setCurrentPrinter(int index)\n{\n    Q_ASSERT(index &gt;= 0 &amp;&amp; index &lt;= prnCount);\n    if (index == prnCount)\n        return 0;\n    currPrinterIndex = index;\n    if (currPPD)\n        _ppdClose(currPPD);\n    currPPD = 0;\n    page_sizes = 0;\n    const char *ppdFile = _cupsGetPPD(printers[index].name);\n    if (!ppdFile)\n      return 0;\n    currPPD = _ppdOpenFile(ppdFile);\n    unlink(ppdFile);\n    // marking default options\n    _ppdMarkDefaults(currPPD);\n    // marking options explicitly set\n    _cupsMarkOptions(currPPD, printers[currPrinterIndex].num_options, printers[currPrinterIndex].options);\n    // getting pointer to page sizes\n    page_sizes = ppdOption(&quot;PageSize&quot;);\n    return currPPD;\n}\nint QCUPSSupport::currentPrinterIndex() const\n{\n    return currPrinterIndex;\n}\nbool QCUPSSupport::isAvailable()\n{\n    if(!cupsLoaded)\n        resolveCups();\n    return _cupsGetDests &amp;&amp;\n        _cupsFreeDests &amp;&amp;\n        _cupsGetPPD &amp;&amp;\n        _ppdOpenFile &amp;&amp;\n        _ppdMarkDefaults &amp;&amp;\n        _ppdClose &amp;&amp;\n        _cupsMarkOptions &amp;&amp;\n        _ppdMarkOption &amp;&amp;\n        _cupsFreeOptions &amp;&amp;\n        _cupsSetDests &amp;&amp;\n        _cupsLangGet &amp;&amp;\n        _cupsLangEncoding &amp;&amp;\n        _cupsAddOption &amp;&amp;\n        (qt_cups_num_printers &gt; 0);\n}\nconst ppd_option_t* QCUPSSupport::ppdOption(const char *key) const\n{\n    if (currPPD) {\n        for (int gr = 0; gr &lt; currPPD-&gt;num_groups; ++gr) {\n            for (int opt = 0; opt &lt; currPPD-&gt;groups[gr].num_options; ++opt) {\n                if (qstrcmp(currPPD-&gt;groups[gr].options[opt].keyword, key) == 0)\n                    return &amp;currPPD-&gt;groups[gr].options[opt];\n            }\n        }\n    }\n    return 0;\n}\nconst cups_option_t* QCUPSSupport::printerOption(const QString &amp;key) const\n{\n    for (int i = 0; i &lt; printers[currPrinterIndex].num_options; ++i) {\n        if (QLatin1String(printers[currPrinterIndex].options[i].name) == key)\n            return &amp;printers[currPrinterIndex].options[i];\n    }\n    return 0;\n}\nconst ppd_option_t* QCUPSSupport::pageSizes() const\n{\n    return page_sizes;\n}\nint QCUPSSupport::markOption(const char* name, const char* value)\n{\n    return _ppdMarkOption(currPPD, name, value);\n}\nvoid QCUPSSupport::saveOptions(QList&lt;const ppd_option_t*&gt; options, QList&lt;const char*&gt; markedOptions)\n{\n    int oldOptionCount = printers[currPrinterIndex].num_options;\n    cups_option_t* oldOptions = printers[currPrinterIndex].options;\n    int newOptionCount = 0;\n    cups_option_t* newOptions = 0;\n    // copying old options that are not on the new list\n    for (int i = 0; i &lt; oldOptionCount; ++i) {\n        bool contains = false;\n        for (int j = 0; j &lt; options.count(); ++j) {\n            if (qstrcmp(options.at(j)-&gt;keyword, oldOptions[i].name) == 0) {\n                contains = true;\n                break;\n            }\n        }\n        if (!contains) {\n            newOptionCount = _cupsAddOption(oldOptions[i].name, oldOptions[i].value, newOptionCount, &amp;newOptions);\n        }\n    }\n    // we can release old option list\n     _cupsFreeOptions(oldOptionCount, oldOptions);\n    // adding marked options\n    for (int i = 0; i &lt; markedOptions.count(); ++i) {\n        const char* name = markedOptions.at(i);\n        ++i;\n        newOptionCount = _cupsAddOption(name, markedOptions.at(i), newOptionCount, &amp;newOptions);\n    }\n    // placing the new option list\n    printers[currPrinterIndex].num_options = newOptionCount;\n    printers[currPrinterIndex].options = newOptions;\n    // saving new default values\n    _cupsSetDests(prnCount, printers);\n}\nQRect QCUPSSupport::paperRect(const char *choice) const\n{\n    if (!currPPD)\n        return QRect();\n    for (int i = 0; i &lt; currPPD-&gt;num_sizes; ++i) {\n        if (qstrcmp(currPPD-&gt;sizes[i].name, choice) == 0)\n            return QRect(0, 0, qRound(currPPD-&gt;sizes[i].width), qRound(currPPD-&gt;sizes[i].length));\n    }\n    return QRect();\n}\nQRect QCUPSSupport::pageRect(const char *choice) const\n{\n    if (!currPPD)\n        return QRect();\n    for (int i = 0; i &lt; currPPD-&gt;num_sizes; ++i) {\n        if (qstrcmp(currPPD-&gt;sizes[i].name, choice) == 0)\n            return QRect(qRound(currPPD-&gt;sizes[i].left),\n                         qRound(currPPD-&gt;sizes[i].length - currPPD-&gt;sizes[i].top),\n                         qRound(currPPD-&gt;sizes[i].right - currPPD-&gt;sizes[i].left),\n                         qRound(currPPD-&gt;sizes[i].top - currPPD-&gt;sizes[i].bottom));\n    }\n    return QRect();\n}\nQStringList QCUPSSupport::options() const\n{\n    QStringList list;\n    collectMarkedOptions(list);\n    return list;\n}\nbool QCUPSSupport::printerHasPPD(const char *printerName)\n{\n    if (!isAvailable())\n        return false;\n    const char *ppdFile = _cupsGetPPD(printerName);\n    if (ppdFile)\n        unlink(ppdFile);\n    return (ppdFile != 0);\n}\nQString QCUPSSupport::unicodeString(const char *s)\n{\n#ifndef QT_NO_TEXTCODEC\n    return codec-&gt;toUnicode(s);\n#else\n    return QLatin1String(s);\n#endif\n}\nvoid QCUPSSupport::collectMarkedOptions(QStringList&amp; list, const ppd_group_t* group) const\n{\n    if (group == 0) {\n        if (!currPPD)\n            return;\n        for (int i = 0; i &lt; currPPD-&gt;num_groups; ++i) {\n            collectMarkedOptions(list, &amp;currPPD-&gt;groups[i]);\n            collectMarkedOptionsHelper(list, &amp;currPPD-&gt;groups[i]);\n        }\n    } else {\n        for (int i = 0; i &lt; group-&gt;num_subgroups; ++i)\n            collectMarkedOptionsHelper(list, &amp;group-&gt;subgroups[i]);\n    }\n}\nvoid QCUPSSupport::collectMarkedOptionsHelper(QStringList&amp; list, const ppd_group_t* group) const\n{\n    for (int i = 0; i &lt; group-&gt;num_options; ++i) {\n        for (int j = 0; j &lt; group-&gt;options[i].num_choices; ++j) {\n            if (group-&gt;options[i].choices[j].marked == 1 &amp;&amp; qstrcmp(group-&gt;options[i].choices[j].choice, group-&gt;options[i].defchoice) != 0)\n                list &lt;&lt; QString::fromLocal8Bit(group-&gt;options[i].keyword) &lt;&lt; QString::fromLocal8Bit(group-&gt;options[i].choices[j].choice);\n        }\n    }\n}\nQPair&lt;int, QString&gt; QCUPSSupport::tempFd()\n{\n    char filename[512];\n    int fd = _cupsTempFd(filename, 512);\n    return QPair&lt;int, QString&gt;(fd, QString::fromLocal8Bit(filename));\n}\n// Prints the given file and returns a job id.\nint QCUPSSupport::printFile(const char * printerName, const char * filename, const char * title,\n                            int num_options, cups_option_t * options)\n{\n    return _cupsPrintFile(printerName, filename, title, num_options, options);\n}\nQT_END_NAMESPACE\n#endif // QT_NO_CUPS</code></pre><p>总代码量大概也就600行，简单的来讲，Qt通过函数resolveCups()把cups的库函数封装了起来。别说一个博士生，估计一个刚上班的本科生看这点代码去适配Linux下的驱动小半天也就搞完了，更何况Qt都已经封装好了给大家使用了。</p>\n<p>下边的代码是cups所有的库函数。</p>\n<pre><code>typedef int (*CupsGetDests)(cups_dest_t **dests);\ntypedef void (*CupsFreeDests)(int num_dests, cups_dest_t *dests);\ntypedef const char* (*CupsGetPPD)(const char *printer);\ntypedef int (*CupsMarkOptions)(ppd_file_t *ppd, int num_options, cups_option_t *options);\ntypedef ppd_file_t* (*PPDOpenFile)(const char *filename);\ntypedef void (*PPDMarkDefaults)(ppd_file_t *ppd);\ntypedef int (*PPDMarkOption)(ppd_file_t *ppd, const char *keyword, const char *option);\ntypedef void (*PPDClose)(ppd_file_t *ppd);\ntypedef int (*PPDMarkOption)(ppd_file_t *ppd, const char *keyword, const char *option);\ntypedef void (*CupsFreeOptions)(int num_options, cups_option_t *options);\ntypedef void (*CupsSetDests)(int num_dests, cups_dest_t *dests);\ntypedef cups_lang_t* (*CupsLangGet)(const char *language);\ntypedef const char* (*CupsLangEncoding)(cups_lang_t *language);\ntypedef int (*CupsAddOption)(const char *name, const char *value, int num_options, cups_option_t **options);\ntypedef int (*CupsTempFd)(char *name, int len);\ntypedef int (*CupsPrintFile)(const char * name, const char * filename, const char * title, int num_options, cups_option_t * options);\nstatic bool cupsLoaded = false;\nstatic int qt_cups_num_printers = 0;\nstatic CupsGetDests _cupsGetDests = 0;\nstatic CupsFreeDests _cupsFreeDests = 0;\nstatic CupsGetPPD _cupsGetPPD = 0;\nstatic PPDOpenFile _ppdOpenFile = 0;\nstatic PPDMarkDefaults _ppdMarkDefaults = 0;\nstatic PPDClose _ppdClose = 0;\nstatic CupsMarkOptions _cupsMarkOptions = 0;\nstatic PPDMarkOption _ppdMarkOption = 0;\nstatic CupsFreeOptions _cupsFreeOptions = 0;\nstatic CupsSetDests _cupsSetDests = 0;\nstatic CupsLangGet _cupsLangGet = 0;\nstatic CupsLangEncoding _cupsLangEncoding = 0;\nstatic CupsAddOption _cupsAddOption = 0;\nstatic CupsTempFd _cupsTempFd = 0;\nstatic CupsPrintFile _cupsPrintFile = 0;</code></pre><p>Qt的QPrinter打印对话框中的属性设置实际上就是调用的QCUPSSupport来设置的属性，对于程序员来讲，只需要关心QCUPSSupport外边暴露的接口就可以了。</p>\n<h1 id=\"TIPS\"><a href=\"#TIPS\" class=\"headerlink\" title=\"TIPS\"></a>TIPS</h1><p>实际上QCUPSSupport在使用中还是有两个比较严重的问题，但是都不是Qt的锅，基本上都是CUPS的问题</p>\n<h2 id=\"QCUPSSupport初始化过慢\"><a href=\"#QCUPSSupport初始化过慢\" class=\"headerlink\" title=\"QCUPSSupport初始化过慢\"></a>QCUPSSupport初始化过慢</h2><p>QCUPSSupport初始化过慢，慢到了解析ppd驱动文件上。相应的QPrinter的构造函数也比较慢，所以尽量要申请一个QPrinter的变量来控制打印机属性，或者少用。当然这是代码设计的问题了。</p>\n<h2 id=\"ppdMarkOption\"><a href=\"#ppdMarkOption\" class=\"headerlink\" title=\"_ppdMarkOption\"></a>_ppdMarkOption</h2><p>_ppdMarkOption 这个函数是设置打印机属性的。成功返回0，失败返回非0。</p>\n<p>ppd驱动文件中有很多打印机的属性设置。</p>\n<p>有的打印机某几个选项是冲突的，比如有的打印机可以设置A5纸张，但是不能同时设置双面打印。如果同时设置，实际上是设置失效的。比如，这时候，你先设置好了纸张大小A5，这时候再去设置打印机属性双面长边打印。这时候_ppdMarkOption是返回非0。（也就是这个设置失败了）。但是，敲重点，但是，即使设置错误，双面打印的属性依旧设置到了该打印机中，这时候再去打印，实际上是不会双面打印出来的。</p>\n<p>上Github上看了看 CUPS中 _ppdMarkOption的实现源码，发现这个函数设计就是这样的,即使设置失败也不会设置回去原来的值。这样只能由我们调用者去兼容这个恶心的函数接口了。</p>\n<h1 id=\"至于为啥没有上Qt5的源码\"><a href=\"#至于为啥没有上Qt5的源码\" class=\"headerlink\" title=\"至于为啥没有上Qt5的源码\"></a>至于为啥没有上Qt5的源码</h1><p>Qt5的工程结构已经变了cups的代码一部分呢已经放到qpainter里了。原理没变。</p>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js\"></script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js\"></script><textarea id=\"flowchart-0-code\" style=\"display: none\">st=>start: QPrinter\nop=>operation: QCUPSSupport\nop1=>operation: CUPS\ne=>end: Linux Core\n\nst->op->op1->e</textarea><textarea id=\"flowchart-0-options\" style=\"display: none\">{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12}</textarea><script>  var code = document.getElementById(\"flowchart-0-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value));  var diagram = flowchart.parse(code);  diagram.drawSVG(\"flowchart-0\", options);</script>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Qt在Linux下打印机的原理以及源码相关知识。<br>下边我就详细的讲一下Linux下的打印机原理。</p>\n<h1 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h1><p>Linux下简单的流程就是这样</p>\n<div id=\"flowchart-0\" class=\"flow-chart\"></div>\n\n\n<h1 id=\"CUPS\"><a href=\"#CUPS\" class=\"headerlink\" title=\"CUPS\"></a>CUPS</h1><p>目前Linux上打印的通用协议是CUPS协议。目前由苹果公司来维护。算了我还是粘一下wiki的词条吧。</p>\n<p>wiki词条</p>\n<blockquote>\n<p>CUPS (formerly an acronym for Common UNIX Printing System) is a modular printing system for Unix-like computer operating systems which allows a computer to act as a print server. A computer running CUPS is a host that can accept print jobs from client computers, process them, and send them to the appropriate printer.<br>CUPS consists of a print spooler and scheduler, a filter system that converts the print data to a format that the printer will understand, and a backend system that sends this data to the print device. CUPS uses the Internet Printing Protocol (IPP) as the basis for managing print jobs and queues. It also provides the traditional command line interfaces for the System V and Berkeley print systems, and provides support for the Berkeley print system’s Line Printer Daemon protocol and limited support for the server message block (SMB) protocol. System administrators can configure the device drivers which CUPS supplies by editing text files in Adobe’s PostScript Printer Description (PPD) format. There are a number of user interfaces for different pl#atforms that can configure CUPS, and it has a built-in web-based interface. CUPS is free software, provided under the Apache License. </p>\n</blockquote>\n<blockquote>\n<p>CUPS（前为Common Unix Printing System，即UNIX通用打印系统的缩写，但现无官方全名[来源请求]）是一个类Unix操作系统的组合式印刷系统，允许一台计算机作为打印服务器。CUPS接受一个客户端的计算机进程，并送到相应的打印机。<br>CUPS是自由软件，使用GNU通用公共许可证和GNU宽通用公共许可证的第2版。<br>迈克尔·斯维特，Easy Software Products的拥有者，于1997年开始开发CUPS。首次公开测试版于1999年发布。[2]原本设计的CUPS使用行式打印机后台程序协议，但由于LPD的限制和供应商不兼容，所以由互联网打印协议(IPP)代替。CUPS被迅速默认为一些Linux发行版的打印系统，如Red Hat Linux。2002年3月，苹果公司在Mac OS X v10.2中采用了CUPS。[3]2007年2月，苹果公司聘请了迈克尔·斯维特并购买了CUPS的源代码。[4]</p>\n</blockquote>\n<p>再次说一遍 <em>目前Unix系列的打印原理都是走的该协议。</em></p>\n<h2 id=\"CUPS是开源的\"><a href=\"#CUPS是开源的\" class=\"headerlink\" title=\"CUPS是开源的\"></a>CUPS是开源的</h2><ul>\n<li>官网 <a href=\"https://www.cups.org/\" target=\"_blank\" rel=\"noopener\">https://www.cups.org/</a> </li>\n<li>源码 <a href=\"https://github.com/apple/cups\" target=\"_blank\" rel=\"noopener\">https://github.com/apple/cups</a></li>\n</ul>\n<p>我读过这里的源码，为了验证下边有个纠结的问题。全是c写的，也不难。</p>\n<h2 id=\"Linux下的驱动\"><a href=\"#Linux下的驱动\" class=\"headerlink\" title=\"Linux下的驱动\"></a>Linux下的驱动</h2><p>秉承着Linux下的原则，一切皆文件，实际上Linux下的打印机驱动也是文件，在目录/etc/cups/ppd文件夹下。可以随意装个虚拟驱动来看下</p>\n<p>简单的给大家看几行ppd文件，这是我本地下的驱动文件</p>\n<pre><code>*PPD-Adobe: &quot;4.3&quot;\n*%%%% PPD file for Generic Text-Only Printer with CUPS.\n*%%%% Created by the CUPS PPD Compiler CUPS v2.2.7.\n*% (c) 2014 OpenPrinting\n*FormatVersion: &quot;4.3&quot;\n*FileVersion: &quot;1.0&quot;\n*LanguageVersion: English\n*LanguageEncoding: ISOLatin1\n*PCFileName: &quot;textonly.ppd&quot;\n*Product: &quot;(Generic Text-Only Printer)&quot;\n*Manufacturer: &quot;Generic&quot;\n*ModelName: &quot;Generic Text-Only Printer&quot;\n*ShortNickName: &quot;Generic Text-Only Printer&quot;\n*NickName: &quot;Generic Text-Only Printer&quot;\n*PSVersion: &quot;(3010.000) 0&quot;\n*LanguageLevel: &quot;3&quot;\n*ColorDevice: False\n*DefaultColorSpace: Gray\n*FileSystem: False\n*Throughput: &quot;1&quot;\n*LandscapeOrientation: Plus90\n*TTRasterizer: Type42\n*% Driver-defined attributes...\n*cupsFilter2: &quot;text/plain text/plain 0 texttotext&quot;\n*RequiresPageRegion All: True\n*1284DeviceID: &quot;MFG:Generic;MDL:Text-Only Printer;DES:Generic Text-Only Printer;CLS:PRINTER;CMD:TXT;DRV:Dtextonly,R1,M0;&quot;\n*cupsVersion: 2.2\n*cupsModelNumber: 0\n*cupsManualCopies: True\n*cupsFilter: &quot;text/plain 0 texttotext&quot;\n*cupsLanguages: &quot;en&quot;</code></pre><p>里边主要是一些字符串信息。你可以简单的理解，cups就是来解析ppd文件中的字符串信息的。</p>\n<h2 id=\"Qt对CUPS的支持。\"><a href=\"#Qt对CUPS的支持。\" class=\"headerlink\" title=\"Qt对CUPS的支持。\"></a>Qt对CUPS的支持。</h2><p>实际上Qt对CUPS的支持是相当好的，源码级别的话都不到千行，将cups提供的信息封装了一层Qt的API来给大家使用。实际上QPrinter也是调用的Qt封装的QCUPSSupport。注意一下QPrinter在Linux下的初始化是非常慢的。不要频繁调用。</p>\n<p>上源码QCUPSSupport</p>\n<pre><code>//Qt4.8.7/qt-everywhere-opensource-src-4.8.7/src/gui/painting/ 源码在这里\n/****************************************************************************\n**\n** Copyright (C) 2015 The Qt Company Ltd.\n** Contact: http://www.qt.io/licensing/\n**\n** This file is part of the QtGui module of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:LGPL$\n** Commercial License Usage\n** Licensees holding valid commercial Qt licenses may use this file in\n** accordance with the commercial license agreement provided with the\n** Software or, alternatively, in accordance with the terms contained in\n** a written agreement between you and The Qt Company. For licensing terms\n** and conditions see http://www.qt.io/terms-conditions. For further\n** information use the contact form at http://www.qt.io/contact-us.\n**\n** GNU Lesser General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU Lesser\n** General Public License version 2.1 or version 3 as published by the Free\n** Software Foundation and appearing in the file LICENSE.LGPLv21 and\n** LICENSE.LGPLv3 included in the packaging of this file. Please review the\n** following information to ensure the GNU Lesser General Public License\n** requirements will be met: https://www.gnu.org/licenses/lgpl.html and\n** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.\n**\n** As a special exception, The Qt Company gives you certain additional\n** rights. These rights are described in The Qt Company LGPL Exception\n** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.\n**\n** GNU General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU\n** General Public License version 3.0 as published by the Free Software\n** Foundation and appearing in the file LICENSE.GPL included in the\n** packaging of this file. Please review the following information to\n** ensure the GNU General Public License version 3.0 requirements will be\n** met: http://www.gnu.org/copyleft/gpl.html.\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n#ifndef QCUPS_P_H\n#define QCUPS_P_H\n//\n// W A R N I N G\n// -------------\n//\n// This file is not part of the Qt API. It exists purely as an\n// implementation detail. This header file may change from version to\n// version without notice, or even be removed.\n//\n// We mean it.\n//\n#include &quot;QtCore/qstring.h&quot;\n#include &quot;QtCore/qstringlist.h&quot;\n#include &quot;QtGui/qprinter.h&quot;\n#ifndef QT_NO_CUPS\n#include &lt;QtCore/qlibrary.h&gt;\n#include &lt;cups/cups.h&gt;\n#include &lt;cups/ppd.h&gt;\nQT_BEGIN_NAMESPACE\nQ_DECLARE_TYPEINFO(cups_option_t, Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE);\nclass QCUPSSupport\n{\npublic:\n    QCUPSSupport();\n    ~QCUPSSupport();\n    static bool isAvailable();\n    static int cupsVersion() { return isAvailable() ? CUPS_VERSION_MAJOR*10000+CUPS_VERSION_MINOR*100+CUPS_VERSION_PATCH : 0; }\n    int availablePrintersCount() const;\n    const cups_dest_t* availablePrinters() const;\n    int currentPrinterIndex() const;\n    const ppd_file_t* setCurrentPrinter(int index);\n    const ppd_file_t* currentPPD() const;\n    const ppd_option_t* ppdOption(const char *key) const;\n    const cups_option_t* printerOption(const QString &amp;key) const;\n    const ppd_option_t* pageSizes() const;\n    int markOption(const char* name, const char* value);\n    void saveOptions(QList&lt;const ppd_option_t*&gt; options, QList&lt;const char*&gt; markedOptions);\n    QRect paperRect(const char *choice) const;\n    QRect pageRect(const char *choice) const;\n    QStringList options() const;\n    static bool printerHasPPD(const char *printerName);\n    QString unicodeString(const char *s);\n    QPair&lt;int, QString&gt; tempFd();\n    int printFile(const char * printerName, const char * filename, const char * title,\n                  int num_options, cups_option_t * options);\nprivate:\n    void collectMarkedOptions(QStringList&amp; list, const ppd_group_t* group = 0) const;\n    void collectMarkedOptionsHelper(QStringList&amp; list, const ppd_group_t* group) const;\n    int prnCount;\n    cups_dest_t *printers;\n    const ppd_option_t* page_sizes;\n    int currPrinterIndex;\n    ppd_file_t *currPPD;\n#ifndef QT_NO_TEXTCODEC\n    QTextCodec *codec;\n#endif\n};\nQT_END_NAMESPACE\n#endif // QT_NO_CUPS\n#endif</code></pre><p>cpp</p>\n<pre><code>//Qt4.8.7/qt-everywhere-opensource-src-4.8.7/src/gui/painting/qcups.cpp\n\n/****************************************************************************\n**\n** Copyright (C) 2015 The Qt Company Ltd.\n** Contact: http://www.qt.io/licensing/\n**\n** This file is part of the QtGui module of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:LGPL$\n** Commercial License Usage\n** Licensees holding valid commercial Qt licenses may use this file in\n** accordance with the commercial license agreement provided with the\n** Software or, alternatively, in accordance with the terms contained in\n** a written agreement between you and The Qt Company. For licensing terms\n** and conditions see http://www.qt.io/terms-conditions. For further\n** information use the contact form at http://www.qt.io/contact-us.\n**\n** GNU Lesser General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU Lesser\n** General Public License version 2.1 or version 3 as published by the Free\n** Software Foundation and appearing in the file LICENSE.LGPLv21 and\n** LICENSE.LGPLv3 included in the packaging of this file. Please review the\n** following information to ensure the GNU Lesser General Public License\n** requirements will be met: https://www.gnu.org/licenses/lgpl.html and\n** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.\n**\n** As a special exception, The Qt Company gives you certain additional\n** rights. These rights are described in The Qt Company LGPL Exception\n** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.\n**\n** GNU General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU\n** General Public License version 3.0 as published by the Free Software\n** Foundation and appearing in the file LICENSE.GPL included in the\n** packaging of this file. Please review the following information to\n** ensure the GNU General Public License version 3.0 requirements will be\n** met: http://www.gnu.org/copyleft/gpl.html.\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n#include &lt;qdebug.h&gt;\n#include &quot;qcups_p.h&quot;\n#ifndef QT_NO_CUPS\n#ifndef QT_LINUXBASE // LSB merges everything into cups.h\n# include &lt;cups/language.h&gt;\n#endif\n#include &lt;qtextcodec.h&gt;\nQT_BEGIN_NAMESPACE\ntypedef int (*CupsGetDests)(cups_dest_t **dests);\ntypedef void (*CupsFreeDests)(int num_dests, cups_dest_t *dests);\ntypedef const char* (*CupsGetPPD)(const char *printer);\ntypedef int (*CupsMarkOptions)(ppd_file_t *ppd, int num_options, cups_option_t *options);\ntypedef ppd_file_t* (*PPDOpenFile)(const char *filename);\ntypedef void (*PPDMarkDefaults)(ppd_file_t *ppd);\ntypedef int (*PPDMarkOption)(ppd_file_t *ppd, const char *keyword, const char *option);\ntypedef void (*PPDClose)(ppd_file_t *ppd);\ntypedef int (*PPDMarkOption)(ppd_file_t *ppd, const char *keyword, const char *option);\ntypedef void (*CupsFreeOptions)(int num_options, cups_option_t *options);\ntypedef void (*CupsSetDests)(int num_dests, cups_dest_t *dests);\ntypedef cups_lang_t* (*CupsLangGet)(const char *language);\ntypedef const char* (*CupsLangEncoding)(cups_lang_t *language);\ntypedef int (*CupsAddOption)(const char *name, const char *value, int num_options, cups_option_t **options);\ntypedef int (*CupsTempFd)(char *name, int len);\ntypedef int (*CupsPrintFile)(const char * name, const char * filename, const char * title, int num_options, cups_option_t * options);\nstatic bool cupsLoaded = false;\nstatic int qt_cups_num_printers = 0;\nstatic CupsGetDests _cupsGetDests = 0;\nstatic CupsFreeDests _cupsFreeDests = 0;\nstatic CupsGetPPD _cupsGetPPD = 0;\nstatic PPDOpenFile _ppdOpenFile = 0;\nstatic PPDMarkDefaults _ppdMarkDefaults = 0;\nstatic PPDClose _ppdClose = 0;\nstatic CupsMarkOptions _cupsMarkOptions = 0;\nstatic PPDMarkOption _ppdMarkOption = 0;\nstatic CupsFreeOptions _cupsFreeOptions = 0;\nstatic CupsSetDests _cupsSetDests = 0;\nstatic CupsLangGet _cupsLangGet = 0;\nstatic CupsLangEncoding _cupsLangEncoding = 0;\nstatic CupsAddOption _cupsAddOption = 0;\nstatic CupsTempFd _cupsTempFd = 0;\nstatic CupsPrintFile _cupsPrintFile = 0;\nstatic void resolveCups()\n{\n    QLibrary cupsLib(QLatin1String(&quot;cups&quot;), 2);\n    if(cupsLib.load()) {\n        _cupsGetDests = (CupsGetDests) cupsLib.resolve(&quot;cupsGetDests&quot;);\n        _cupsFreeDests = (CupsFreeDests) cupsLib.resolve(&quot;cupsFreeDests&quot;);\n        _cupsGetPPD = (CupsGetPPD) cupsLib.resolve(&quot;cupsGetPPD&quot;);\n        _cupsLangGet = (CupsLangGet) cupsLib.resolve(&quot;cupsLangGet&quot;);\n        _cupsLangEncoding = (CupsLangEncoding) cupsLib.resolve(&quot;cupsLangEncoding&quot;);\n        _ppdOpenFile = (PPDOpenFile) cupsLib.resolve(&quot;ppdOpenFile&quot;);\n        _ppdMarkDefaults = (PPDMarkDefaults) cupsLib.resolve(&quot;ppdMarkDefaults&quot;);\n        _ppdClose = (PPDClose) cupsLib.resolve(&quot;ppdClose&quot;);\n        _cupsMarkOptions = (CupsMarkOptions) cupsLib.resolve(&quot;cupsMarkOptions&quot;);\n        _ppdMarkOption = (PPDMarkOption) cupsLib.resolve(&quot;ppdMarkOption&quot;);\n        _cupsFreeOptions = (CupsFreeOptions) cupsLib.resolve(&quot;cupsFreeOptions&quot;);\n        _cupsSetDests = (CupsSetDests) cupsLib.resolve(&quot;cupsSetDests&quot;);\n        _cupsAddOption = (CupsAddOption) cupsLib.resolve(&quot;cupsAddOption&quot;);\n        _cupsTempFd = (CupsTempFd) cupsLib.resolve(&quot;cupsTempFd&quot;);\n        _cupsPrintFile = (CupsPrintFile) cupsLib.resolve(&quot;cupsPrintFile&quot;);\n        if (_cupsGetDests &amp;&amp; _cupsFreeDests) {\n            cups_dest_t *printers;\n            int num_printers = _cupsGetDests(&amp;printers);\n            if (num_printers)\n                _cupsFreeDests(num_printers, printers);\n            qt_cups_num_printers = num_printers;\n        }\n    }\n    cupsLoaded = true;\n}\n// ================ CUPS Support class ========================\nQCUPSSupport::QCUPSSupport()\n    :\n    prnCount(0),\n    printers(0),\n    page_sizes(0),\n    currPrinterIndex(0),\n    currPPD(0)\n{\n    if (!cupsLoaded)\n        resolveCups();\n    // getting all available printers\n    if (!isAvailable())\n        return;\n    // Update the available printer count\n    qt_cups_num_printers = prnCount = _cupsGetDests(&amp;printers);\n    for (int i = 0; i &lt; prnCount; ++i) {\n        if (printers[i].is_default) {\n            currPrinterIndex = i;\n            setCurrentPrinter(i);\n            break;\n        }\n    }\n#ifndef QT_NO_TEXTCODEC\n    cups_lang_t *cupsLang = _cupsLangGet(0);\n    codec = QTextCodec::codecForName(_cupsLangEncoding(cupsLang));\n    if (!codec)\n        codec = QTextCodec::codecForLocale();\n#endif\n}\nQCUPSSupport::~QCUPSSupport()\n{\n     if (currPPD)\n        _ppdClose(currPPD);\n     if (prnCount)\n         _cupsFreeDests(prnCount, printers);\n}\nint QCUPSSupport::availablePrintersCount() const\n{\n    return prnCount;\n}\nconst cups_dest_t* QCUPSSupport::availablePrinters() const\n{\n    return printers;\n}\nconst ppd_file_t* QCUPSSupport::currentPPD() const\n{\n    return currPPD;\n}\nconst ppd_file_t* QCUPSSupport::setCurrentPrinter(int index)\n{\n    Q_ASSERT(index &gt;= 0 &amp;&amp; index &lt;= prnCount);\n    if (index == prnCount)\n        return 0;\n    currPrinterIndex = index;\n    if (currPPD)\n        _ppdClose(currPPD);\n    currPPD = 0;\n    page_sizes = 0;\n    const char *ppdFile = _cupsGetPPD(printers[index].name);\n    if (!ppdFile)\n      return 0;\n    currPPD = _ppdOpenFile(ppdFile);\n    unlink(ppdFile);\n    // marking default options\n    _ppdMarkDefaults(currPPD);\n    // marking options explicitly set\n    _cupsMarkOptions(currPPD, printers[currPrinterIndex].num_options, printers[currPrinterIndex].options);\n    // getting pointer to page sizes\n    page_sizes = ppdOption(&quot;PageSize&quot;);\n    return currPPD;\n}\nint QCUPSSupport::currentPrinterIndex() const\n{\n    return currPrinterIndex;\n}\nbool QCUPSSupport::isAvailable()\n{\n    if(!cupsLoaded)\n        resolveCups();\n    return _cupsGetDests &amp;&amp;\n        _cupsFreeDests &amp;&amp;\n        _cupsGetPPD &amp;&amp;\n        _ppdOpenFile &amp;&amp;\n        _ppdMarkDefaults &amp;&amp;\n        _ppdClose &amp;&amp;\n        _cupsMarkOptions &amp;&amp;\n        _ppdMarkOption &amp;&amp;\n        _cupsFreeOptions &amp;&amp;\n        _cupsSetDests &amp;&amp;\n        _cupsLangGet &amp;&amp;\n        _cupsLangEncoding &amp;&amp;\n        _cupsAddOption &amp;&amp;\n        (qt_cups_num_printers &gt; 0);\n}\nconst ppd_option_t* QCUPSSupport::ppdOption(const char *key) const\n{\n    if (currPPD) {\n        for (int gr = 0; gr &lt; currPPD-&gt;num_groups; ++gr) {\n            for (int opt = 0; opt &lt; currPPD-&gt;groups[gr].num_options; ++opt) {\n                if (qstrcmp(currPPD-&gt;groups[gr].options[opt].keyword, key) == 0)\n                    return &amp;currPPD-&gt;groups[gr].options[opt];\n            }\n        }\n    }\n    return 0;\n}\nconst cups_option_t* QCUPSSupport::printerOption(const QString &amp;key) const\n{\n    for (int i = 0; i &lt; printers[currPrinterIndex].num_options; ++i) {\n        if (QLatin1String(printers[currPrinterIndex].options[i].name) == key)\n            return &amp;printers[currPrinterIndex].options[i];\n    }\n    return 0;\n}\nconst ppd_option_t* QCUPSSupport::pageSizes() const\n{\n    return page_sizes;\n}\nint QCUPSSupport::markOption(const char* name, const char* value)\n{\n    return _ppdMarkOption(currPPD, name, value);\n}\nvoid QCUPSSupport::saveOptions(QList&lt;const ppd_option_t*&gt; options, QList&lt;const char*&gt; markedOptions)\n{\n    int oldOptionCount = printers[currPrinterIndex].num_options;\n    cups_option_t* oldOptions = printers[currPrinterIndex].options;\n    int newOptionCount = 0;\n    cups_option_t* newOptions = 0;\n    // copying old options that are not on the new list\n    for (int i = 0; i &lt; oldOptionCount; ++i) {\n        bool contains = false;\n        for (int j = 0; j &lt; options.count(); ++j) {\n            if (qstrcmp(options.at(j)-&gt;keyword, oldOptions[i].name) == 0) {\n                contains = true;\n                break;\n            }\n        }\n        if (!contains) {\n            newOptionCount = _cupsAddOption(oldOptions[i].name, oldOptions[i].value, newOptionCount, &amp;newOptions);\n        }\n    }\n    // we can release old option list\n     _cupsFreeOptions(oldOptionCount, oldOptions);\n    // adding marked options\n    for (int i = 0; i &lt; markedOptions.count(); ++i) {\n        const char* name = markedOptions.at(i);\n        ++i;\n        newOptionCount = _cupsAddOption(name, markedOptions.at(i), newOptionCount, &amp;newOptions);\n    }\n    // placing the new option list\n    printers[currPrinterIndex].num_options = newOptionCount;\n    printers[currPrinterIndex].options = newOptions;\n    // saving new default values\n    _cupsSetDests(prnCount, printers);\n}\nQRect QCUPSSupport::paperRect(const char *choice) const\n{\n    if (!currPPD)\n        return QRect();\n    for (int i = 0; i &lt; currPPD-&gt;num_sizes; ++i) {\n        if (qstrcmp(currPPD-&gt;sizes[i].name, choice) == 0)\n            return QRect(0, 0, qRound(currPPD-&gt;sizes[i].width), qRound(currPPD-&gt;sizes[i].length));\n    }\n    return QRect();\n}\nQRect QCUPSSupport::pageRect(const char *choice) const\n{\n    if (!currPPD)\n        return QRect();\n    for (int i = 0; i &lt; currPPD-&gt;num_sizes; ++i) {\n        if (qstrcmp(currPPD-&gt;sizes[i].name, choice) == 0)\n            return QRect(qRound(currPPD-&gt;sizes[i].left),\n                         qRound(currPPD-&gt;sizes[i].length - currPPD-&gt;sizes[i].top),\n                         qRound(currPPD-&gt;sizes[i].right - currPPD-&gt;sizes[i].left),\n                         qRound(currPPD-&gt;sizes[i].top - currPPD-&gt;sizes[i].bottom));\n    }\n    return QRect();\n}\nQStringList QCUPSSupport::options() const\n{\n    QStringList list;\n    collectMarkedOptions(list);\n    return list;\n}\nbool QCUPSSupport::printerHasPPD(const char *printerName)\n{\n    if (!isAvailable())\n        return false;\n    const char *ppdFile = _cupsGetPPD(printerName);\n    if (ppdFile)\n        unlink(ppdFile);\n    return (ppdFile != 0);\n}\nQString QCUPSSupport::unicodeString(const char *s)\n{\n#ifndef QT_NO_TEXTCODEC\n    return codec-&gt;toUnicode(s);\n#else\n    return QLatin1String(s);\n#endif\n}\nvoid QCUPSSupport::collectMarkedOptions(QStringList&amp; list, const ppd_group_t* group) const\n{\n    if (group == 0) {\n        if (!currPPD)\n            return;\n        for (int i = 0; i &lt; currPPD-&gt;num_groups; ++i) {\n            collectMarkedOptions(list, &amp;currPPD-&gt;groups[i]);\n            collectMarkedOptionsHelper(list, &amp;currPPD-&gt;groups[i]);\n        }\n    } else {\n        for (int i = 0; i &lt; group-&gt;num_subgroups; ++i)\n            collectMarkedOptionsHelper(list, &amp;group-&gt;subgroups[i]);\n    }\n}\nvoid QCUPSSupport::collectMarkedOptionsHelper(QStringList&amp; list, const ppd_group_t* group) const\n{\n    for (int i = 0; i &lt; group-&gt;num_options; ++i) {\n        for (int j = 0; j &lt; group-&gt;options[i].num_choices; ++j) {\n            if (group-&gt;options[i].choices[j].marked == 1 &amp;&amp; qstrcmp(group-&gt;options[i].choices[j].choice, group-&gt;options[i].defchoice) != 0)\n                list &lt;&lt; QString::fromLocal8Bit(group-&gt;options[i].keyword) &lt;&lt; QString::fromLocal8Bit(group-&gt;options[i].choices[j].choice);\n        }\n    }\n}\nQPair&lt;int, QString&gt; QCUPSSupport::tempFd()\n{\n    char filename[512];\n    int fd = _cupsTempFd(filename, 512);\n    return QPair&lt;int, QString&gt;(fd, QString::fromLocal8Bit(filename));\n}\n// Prints the given file and returns a job id.\nint QCUPSSupport::printFile(const char * printerName, const char * filename, const char * title,\n                            int num_options, cups_option_t * options)\n{\n    return _cupsPrintFile(printerName, filename, title, num_options, options);\n}\nQT_END_NAMESPACE\n#endif // QT_NO_CUPS</code></pre><p>总代码量大概也就600行，简单的来讲，Qt通过函数resolveCups()把cups的库函数封装了起来。别说一个博士生，估计一个刚上班的本科生看这点代码去适配Linux下的驱动小半天也就搞完了，更何况Qt都已经封装好了给大家使用了。</p>\n<p>下边的代码是cups所有的库函数。</p>\n<pre><code>typedef int (*CupsGetDests)(cups_dest_t **dests);\ntypedef void (*CupsFreeDests)(int num_dests, cups_dest_t *dests);\ntypedef const char* (*CupsGetPPD)(const char *printer);\ntypedef int (*CupsMarkOptions)(ppd_file_t *ppd, int num_options, cups_option_t *options);\ntypedef ppd_file_t* (*PPDOpenFile)(const char *filename);\ntypedef void (*PPDMarkDefaults)(ppd_file_t *ppd);\ntypedef int (*PPDMarkOption)(ppd_file_t *ppd, const char *keyword, const char *option);\ntypedef void (*PPDClose)(ppd_file_t *ppd);\ntypedef int (*PPDMarkOption)(ppd_file_t *ppd, const char *keyword, const char *option);\ntypedef void (*CupsFreeOptions)(int num_options, cups_option_t *options);\ntypedef void (*CupsSetDests)(int num_dests, cups_dest_t *dests);\ntypedef cups_lang_t* (*CupsLangGet)(const char *language);\ntypedef const char* (*CupsLangEncoding)(cups_lang_t *language);\ntypedef int (*CupsAddOption)(const char *name, const char *value, int num_options, cups_option_t **options);\ntypedef int (*CupsTempFd)(char *name, int len);\ntypedef int (*CupsPrintFile)(const char * name, const char * filename, const char * title, int num_options, cups_option_t * options);\nstatic bool cupsLoaded = false;\nstatic int qt_cups_num_printers = 0;\nstatic CupsGetDests _cupsGetDests = 0;\nstatic CupsFreeDests _cupsFreeDests = 0;\nstatic CupsGetPPD _cupsGetPPD = 0;\nstatic PPDOpenFile _ppdOpenFile = 0;\nstatic PPDMarkDefaults _ppdMarkDefaults = 0;\nstatic PPDClose _ppdClose = 0;\nstatic CupsMarkOptions _cupsMarkOptions = 0;\nstatic PPDMarkOption _ppdMarkOption = 0;\nstatic CupsFreeOptions _cupsFreeOptions = 0;\nstatic CupsSetDests _cupsSetDests = 0;\nstatic CupsLangGet _cupsLangGet = 0;\nstatic CupsLangEncoding _cupsLangEncoding = 0;\nstatic CupsAddOption _cupsAddOption = 0;\nstatic CupsTempFd _cupsTempFd = 0;\nstatic CupsPrintFile _cupsPrintFile = 0;</code></pre><p>Qt的QPrinter打印对话框中的属性设置实际上就是调用的QCUPSSupport来设置的属性，对于程序员来讲，只需要关心QCUPSSupport外边暴露的接口就可以了。</p>\n<h1 id=\"TIPS\"><a href=\"#TIPS\" class=\"headerlink\" title=\"TIPS\"></a>TIPS</h1><p>实际上QCUPSSupport在使用中还是有两个比较严重的问题，但是都不是Qt的锅，基本上都是CUPS的问题</p>\n<h2 id=\"QCUPSSupport初始化过慢\"><a href=\"#QCUPSSupport初始化过慢\" class=\"headerlink\" title=\"QCUPSSupport初始化过慢\"></a>QCUPSSupport初始化过慢</h2><p>QCUPSSupport初始化过慢，慢到了解析ppd驱动文件上。相应的QPrinter的构造函数也比较慢，所以尽量要申请一个QPrinter的变量来控制打印机属性，或者少用。当然这是代码设计的问题了。</p>\n<h2 id=\"ppdMarkOption\"><a href=\"#ppdMarkOption\" class=\"headerlink\" title=\"_ppdMarkOption\"></a>_ppdMarkOption</h2><p>_ppdMarkOption 这个函数是设置打印机属性的。成功返回0，失败返回非0。</p>\n<p>ppd驱动文件中有很多打印机的属性设置。</p>\n<p>有的打印机某几个选项是冲突的，比如有的打印机可以设置A5纸张，但是不能同时设置双面打印。如果同时设置，实际上是设置失效的。比如，这时候，你先设置好了纸张大小A5，这时候再去设置打印机属性双面长边打印。这时候_ppdMarkOption是返回非0。（也就是这个设置失败了）。但是，敲重点，但是，即使设置错误，双面打印的属性依旧设置到了该打印机中，这时候再去打印，实际上是不会双面打印出来的。</p>\n<p>上Github上看了看 CUPS中 _ppdMarkOption的实现源码，发现这个函数设计就是这样的,即使设置失败也不会设置回去原来的值。这样只能由我们调用者去兼容这个恶心的函数接口了。</p>\n<h1 id=\"至于为啥没有上Qt5的源码\"><a href=\"#至于为啥没有上Qt5的源码\" class=\"headerlink\" title=\"至于为啥没有上Qt5的源码\"></a>至于为啥没有上Qt5的源码</h1><p>Qt5的工程结构已经变了cups的代码一部分呢已经放到qpainter里了。原理没变。</p>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js\"></script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js\"></script><textarea id=\"flowchart-0-code\" style=\"display: none\">st=>start: QPrinter\nop=>operation: QCUPSSupport\nop1=>operation: CUPS\ne=>end: Linux Core\n\nst->op->op1->e</textarea><textarea id=\"flowchart-0-options\" style=\"display: none\">{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12}</textarea><script>  var code = document.getElementById(\"flowchart-0-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value));  var diagram = flowchart.parse(code);  diagram.drawSVG(\"flowchart-0\", options);</script>","categories":[],"tags":[{"name":"Qt","path":"api/tags/Qt.json"},{"name":"Qt源码","path":"api/tags/Qt源码.json"},{"name":"Qt源码剖析","path":"api/tags/Qt源码剖析.json"}]}