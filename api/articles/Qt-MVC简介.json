{"title":"MVC简介","slug":"Qt-MVC简介","date":"2020-07-05T15:07:48.000Z","updated":"2020-07-05T15:11:50.309Z","comments":true,"path":"api/articles/Qt-MVC简介.json","excerpt":null,"covers":["/2020/07/05/qt-mvc-jian-jie/modelview-overview.png"],"content":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>想了好久如何开启这个头，还是拿来主义吧，Qt官方文档 + 我自己的理解。</p>\n<p><a href=\"https://doc.qt.io/qt-5/model-view-programming.html\" target=\"_blank\" rel=\"noopener\">https://doc.qt.io/qt-5/model-view-programming.html</a></p>\n<h1 id=\"MVC我的理解\"><a href=\"#MVC我的理解\" class=\"headerlink\" title=\"MVC我的理解\"></a>MVC我的理解</h1><ul>\n<li>Model - 模型，即一个应用程序对象，提供了一套方法用于展示数据</li>\n<li>View - 即一个界面，用于显示模型中的数据，</li>\n<li>Controller - 我理解为控制，MVC结构中用于控制如何显示，界面有怎样的行为，处于一个核心的位置。</li>\n</ul>\n<h1 id=\"MVC-的定义\"><a href=\"#MVC-的定义\" class=\"headerlink\" title=\"MVC 的定义\"></a>MVC 的定义</h1><blockquote>\n<p>MVC consists of three kinds of objects. The Model is the application object, the View is its screen presentation, and the Controller defines the way the user interface reacts to user input. Before MVC, user interface designs tended to lump these objects together. MVC decouples them to increase flexibility and reuse.</p>\n</blockquote>\n<p>还是直接google translate吧</p>\n<blockquote>\n<p>MVC由三种对象组成。模型是应用程序对象，视图是其屏幕显示，控制器定义了用户界面对用户输入的反应方式。在MVC之前，用户界面设计倾向于将这些对象放在一起。MVC使它们解耦以增加灵活性和重用性。</p>\n</blockquote>\n<h1 id=\"Qt的Model-View架构\"><a href=\"#Qt的Model-View架构\" class=\"headerlink\" title=\"Qt的Model/View架构\"></a>Qt的Model/View架构</h1><p>Qt为开发者提供了一整套Model/View的架构用于展示开发者的数据。而且，这些数据可以通过引入的新的类Delegate来让用户编辑model中的数据，也可以通过delegate来自定义展示我们的原始数据。</p>\n<p>简单的说，我们需要掌握Qt的这几种类，才算真正的掌握了Qt的Model/View架构</p>\n<h2 id=\"模型图\"><a href=\"#模型图\" class=\"headerlink\" title=\"模型图\"></a>模型图</h2><p><img src=\"/2020/07/05/qt-mvc-jian-jie/modelview-overview.png\" alt></p>\n<h2 id=\"Model类\"><a href=\"#Model类\" class=\"headerlink\" title=\"Model类\"></a>Model类</h2><p><a href=\"https://doc.qt.io/qt-5/model-view-programming.html#model-classes\" target=\"_blank\" rel=\"noopener\" title=\"Model类官方简介\">Model类官方简介</a></p>\n<p>可能是最常用的类</p>\n<ul>\n<li>QAbstractItemModel</li>\n</ul>\n<p>所有项目模型均基于QAbstractItemModel类。此类定义了一个接口，供视图和委托用来访问数据。</p>\n<p>QAbstractItemModel提供了一个数据接口，该接口足够灵活，可以处理以表，列表和树的形式表示数据的视图。</p>\n<p>当我们的数据是一个列表或者一个表格时，QAbstractListModel和QAbstractTableModel<br>可能是更好的方法，因为这两个类也是继承自QAbstractItemModel类，这两个类已经有了一些默认实现来方便我们重写。</p>\n<p>Qt现在也提供了一些现有的model来供我们使用</p>\n<ul>\n<li>QStringListModel用于存储QString项目的简单列表。</li>\n<li>QStandardItemModel管理更复杂的项目树结构，每个项目可以包含任意数据。</li>\n<li>QFileSystemModel提供有关本地系统中文件和目录的信息。</li>\n<li>QSqlQueryModel，QSqlTableModel和QSqlRelationalTableModel用于使用模型/视图约定访问数据库。</li>\n</ul>\n<p>如果这些标准模型不符合我们的要求，我们依旧可以重写这三个类来实现我们的要求</p>\n<ul>\n<li>QAbstractItemModel</li>\n<li>QAbstractListModel</li>\n<li>QAbstractTableModel</li>\n</ul>\n<p>一般我们会重写这个类的几个虚函数来进行自定义的控制</p>\n<h2 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h2><p>用于显示各种类型的model</p>\n<ul>\n<li>QListView 显示列表类型的model</li>\n<li>QTableView 显示表格类型的数据</li>\n<li>QTreeView 显示树形结构中的数据模型项。</li>\n</ul>\n<p>这些类均基于QAbstractItemView。</p>\n<p>你也可以自己重写QAbstractItemView</p>\n<h2 id=\"Delegates\"><a href=\"#Delegates\" class=\"headerlink\" title=\"Delegates\"></a>Delegates</h2><p>代理类</p>\n<p>QAbstractItemDelegate是模型/视图框架中委托的抽象基类。</p>\n<p>默认的视图是有一个默认的QStyledItemDelegate的。你可以重写QStyledItemDelegate类来给视图重绘，或者给视图提供编辑功能。</p>\n<h2 id=\"Sorting\"><a href=\"#Sorting\" class=\"headerlink\" title=\"Sorting\"></a>Sorting</h2><p>排序！</p>\n<p>如果我们的模型是可以排序的，我们可以重新实现 QAbstractItemModel，然后把我们的模型添加到QAbstractItemModel的sourcemodel里，然后重写QAbstractItemModel函数来实现我们的model排序。</p>\n<p>当然有一些Qt默认的model是带排序功能的，这里就不详细说明了。接下来我会通过一个结合的栗子来简单讲解这几个模块</p>\n","more":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>想了好久如何开启这个头，还是拿来主义吧，Qt官方文档 + 我自己的理解。</p>\n<p><a href=\"https://doc.qt.io/qt-5/model-view-programming.html\" target=\"_blank\" rel=\"noopener\">https://doc.qt.io/qt-5/model-view-programming.html</a></p>\n<h1 id=\"MVC我的理解\"><a href=\"#MVC我的理解\" class=\"headerlink\" title=\"MVC我的理解\"></a>MVC我的理解</h1><ul>\n<li>Model - 模型，即一个应用程序对象，提供了一套方法用于展示数据</li>\n<li>View - 即一个界面，用于显示模型中的数据，</li>\n<li>Controller - 我理解为控制，MVC结构中用于控制如何显示，界面有怎样的行为，处于一个核心的位置。</li>\n</ul>\n<h1 id=\"MVC-的定义\"><a href=\"#MVC-的定义\" class=\"headerlink\" title=\"MVC 的定义\"></a>MVC 的定义</h1><blockquote>\n<p>MVC consists of three kinds of objects. The Model is the application object, the View is its screen presentation, and the Controller defines the way the user interface reacts to user input. Before MVC, user interface designs tended to lump these objects together. MVC decouples them to increase flexibility and reuse.</p>\n</blockquote>\n<p>还是直接google translate吧</p>\n<blockquote>\n<p>MVC由三种对象组成。模型是应用程序对象，视图是其屏幕显示，控制器定义了用户界面对用户输入的反应方式。在MVC之前，用户界面设计倾向于将这些对象放在一起。MVC使它们解耦以增加灵活性和重用性。</p>\n</blockquote>\n<h1 id=\"Qt的Model-View架构\"><a href=\"#Qt的Model-View架构\" class=\"headerlink\" title=\"Qt的Model/View架构\"></a>Qt的Model/View架构</h1><p>Qt为开发者提供了一整套Model/View的架构用于展示开发者的数据。而且，这些数据可以通过引入的新的类Delegate来让用户编辑model中的数据，也可以通过delegate来自定义展示我们的原始数据。</p>\n<p>简单的说，我们需要掌握Qt的这几种类，才算真正的掌握了Qt的Model/View架构</p>\n<h2 id=\"模型图\"><a href=\"#模型图\" class=\"headerlink\" title=\"模型图\"></a>模型图</h2><p><img src=\"/2020/07/05/qt-mvc-jian-jie/modelview-overview.png\" alt></p>\n<h2 id=\"Model类\"><a href=\"#Model类\" class=\"headerlink\" title=\"Model类\"></a>Model类</h2><p><a href=\"https://doc.qt.io/qt-5/model-view-programming.html#model-classes\" target=\"_blank\" rel=\"noopener\" title=\"Model类官方简介\">Model类官方简介</a></p>\n<p>可能是最常用的类</p>\n<ul>\n<li>QAbstractItemModel</li>\n</ul>\n<p>所有项目模型均基于QAbstractItemModel类。此类定义了一个接口，供视图和委托用来访问数据。</p>\n<p>QAbstractItemModel提供了一个数据接口，该接口足够灵活，可以处理以表，列表和树的形式表示数据的视图。</p>\n<p>当我们的数据是一个列表或者一个表格时，QAbstractListModel和QAbstractTableModel<br>可能是更好的方法，因为这两个类也是继承自QAbstractItemModel类，这两个类已经有了一些默认实现来方便我们重写。</p>\n<p>Qt现在也提供了一些现有的model来供我们使用</p>\n<ul>\n<li>QStringListModel用于存储QString项目的简单列表。</li>\n<li>QStandardItemModel管理更复杂的项目树结构，每个项目可以包含任意数据。</li>\n<li>QFileSystemModel提供有关本地系统中文件和目录的信息。</li>\n<li>QSqlQueryModel，QSqlTableModel和QSqlRelationalTableModel用于使用模型/视图约定访问数据库。</li>\n</ul>\n<p>如果这些标准模型不符合我们的要求，我们依旧可以重写这三个类来实现我们的要求</p>\n<ul>\n<li>QAbstractItemModel</li>\n<li>QAbstractListModel</li>\n<li>QAbstractTableModel</li>\n</ul>\n<p>一般我们会重写这个类的几个虚函数来进行自定义的控制</p>\n<h2 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h2><p>用于显示各种类型的model</p>\n<ul>\n<li>QListView 显示列表类型的model</li>\n<li>QTableView 显示表格类型的数据</li>\n<li>QTreeView 显示树形结构中的数据模型项。</li>\n</ul>\n<p>这些类均基于QAbstractItemView。</p>\n<p>你也可以自己重写QAbstractItemView</p>\n<h2 id=\"Delegates\"><a href=\"#Delegates\" class=\"headerlink\" title=\"Delegates\"></a>Delegates</h2><p>代理类</p>\n<p>QAbstractItemDelegate是模型/视图框架中委托的抽象基类。</p>\n<p>默认的视图是有一个默认的QStyledItemDelegate的。你可以重写QStyledItemDelegate类来给视图重绘，或者给视图提供编辑功能。</p>\n<h2 id=\"Sorting\"><a href=\"#Sorting\" class=\"headerlink\" title=\"Sorting\"></a>Sorting</h2><p>排序！</p>\n<p>如果我们的模型是可以排序的，我们可以重新实现 QAbstractItemModel，然后把我们的模型添加到QAbstractItemModel的sourcemodel里，然后重写QAbstractItemModel函数来实现我们的model排序。</p>\n<p>当然有一些Qt默认的model是带排序功能的，这里就不详细说明了。接下来我会通过一个结合的栗子来简单讲解这几个模块</p>\n","categories":[{"name":"Qt","path":"api/categories/Qt.json"},{"name":"Qt基础教程","path":"api/categories/Qt基础教程.json"}],"tags":[{"name":"Qt","path":"api/tags/Qt.json"},{"name":"Qt基础教程","path":"api/tags/Qt基础教程.json"},{"name":"model","path":"api/tags/model.json"},{"name":"view","path":"api/tags/view.json"}]}